# Пишем контракты на Solidity

В данном разделе не будет гайда по написанию контрактов, однако в формате тезисов будут обозначены некоторые моменты, с которыми мне и моим друзьям приходилось сталкиваться.

### Как изучать Solidity

На самом деле Solidity очень простой и "бедный" язык. Он будет интуитивно понятен любому разработчику, за исключением некоторых моментов, которые я постараюсь описать далее. Изучать его стоит по официальной документации, постоянно эксперементируя \(см главу "Миграции контрактов"\).  
[https://docs.soliditylang.org/en/latest/](https://docs.soliditylang.org/en/latest/)  
  
Так же у Truffle есть свои пакеты, в которых есть неплохие семплы проектов. К примеру [https://www.trufflesuite.com/boxes/metacoin](https://www.trufflesuite.com/boxes/metacoin)  
Можно создать новый проект с предустановленным пакетом:

```text
truffle unbox metacoin
```

Отличный сборник примеров с подробной документацией находится прямо в документации по Solidity:  
[https://docs.soliditylang.org/en/latest/solidity-by-example.html](https://docs.soliditylang.org/en/latest/solidity-by-example.html)

Говоря о примерах кода, нельзя не упомянуть об OpenZeppelin с целой коллекцией контрактов для ревью и использования. О них ниже.  
  
Помимо документаций и сэмплов есть хорошие каналы на YouTube. В частности **Dapp University** и его пятичасовое видео **"Start HERE To Master Blockchain Step-By-Step"**, в котором рассматривается создание как бэкенда, так и фронтенда, очень помогло мне в свое время. Однако, в нем не все освещено, и оно несколько устарело. Между тем, ознакомиться однозначно стоит.  
[https://www.youtube.com/watch?v=sCE-fQJAVQ4](https://www.youtube.com/watch?v=sCE-fQJAVQ4)

### Использование контрактов OpenZeppelin

В качестве референсов, по которым есть смысл учиться, стоит обратить внимание на коллекцию проверенных и безопасных контрактов от OpenZeppelin:

Сайт - [https://openzeppelin.com/contracts/](https://openzeppelin.com/contracts/)  
Потрясающие описания контрактов - [https://docs.openzeppelin.com/contracts](https://docs.openzeppelin.com/contracts)  
Код контрактов - [https://github.com/OpenZeppelin/openzeppelin-contracts](https://github.com/OpenZeppelin/openzeppelin-contracts)

Тут стоит заметить, что "монеты" и "NFT" - это некоторые абстракции, лишь значения в переменных контрактов, в которых описано, кому сколько и что принадлежит. Для того, чтобы с токенами было удобно работать всем, введены стандарты, которые мы знаем как ERC-20, ERC-721, ERC-1155 и т.д. OpenZeppelin предлагает набор проверенных шаблонов, от которых можно \(и очень желательно\) наследовать свои контракты. Вы в любом случае не обязаны реализовывать все интерфейсы, описанные в стандартах, как можете и не ограничиваться ими, но любой контракт, реализующий минимальный интерфейс, к примеру, ERC-20 будет являться токеном.

Установка библиотеки OpenZeppelin \(в дирректории проекта Truffle\)  
\(перед этим желательно сделать **npm init** и ответить на все вопросы, или просто прожать Enter.  В папке появится файл **package.json**\)

```text
npm install @openzeppelin/contracts
```

После этого при создании контракта, его можно наследовать от одного из готовых контрактов OpenZeppelin. К примеру для стандартного токена ERC-20:

```text
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor() ERC20("MyToken", "MTK") {}
}
```

Готово! Теперь стоит переопределить лишь нужные функции, чтобы кастомизировать токеномику, или совершить миграцию контракта, если вам нужен базовый токен.

### Подводные камни Solidity и FAQ

* Solidity - не единственный язык для написания смарт-контрактов. Есть еще **Viper** и **Fe**. Первый умышленно урезан относительно Solidity. В частности, там нет наследований. Однако благодаря этому и Python-стайлу код получается более читаемый. Проект находится в бете, а Solidity является эталоном в индустрии, так что к Viper можно присмотреться, но на данный момент не более. Fe же является преемником Viper. На него тоже можно посмотреть, но учить вместо Solidity, как первый язык для написания смарт-контрактов не стоит.
* Solidity **не поддерживает дробных числел**. Точнее они есть де-факто, но на деле их применение максимально ограничено. Это важно, так как это означает, что в Solidity присутствует лишь целочисленное деление. Именно поэтому все исчесление ведется в минимальных неделимых единицах \(к примеру в wei для Eth\).
* Нельзя просто так **сложить 2 строки**. Точнее можно, но это делается нетривиально, через энкодирование, сложение и обратное декодирование

```text
string(abi.encodePacked("STRING1", "STRING2"))
```

* С **циклами** нужно быть аккуратным, т.к. они могут привести к невероятно огромным комиссиям для взаимодействия с вашим контрактом, и буквально похоронить проект.
* В чем отличие **memory** от **storage**? Переменные в пространстве momory существуют в рамках одного запроса, переменные в пространстве storage сохраняются в блокчейне. Писать в них дороже. Указывать пространство для переменных с динамическим объемом требуемой памяти \(строки, массивы, словари и т.д.\) необходимо явно.
* Что такое **view** и **pure** у функций, и в чем разница? Ключевое слово view означает, что в функции не присутствует запись в storage-переменные. pure означает, что из storage нет даже чтения.
* В глобальном пространстве имен присутствует переменная **msg**. В ней хранятся крайне полезные данные: **msg.sender** - отправитель транзакции/вызова \(кто обратился к функции\), **msg.orgign** - корневой отправитель транзакции/вызова, **msg.value** - количество переданного с транзакцией Eth, и т.д.
* Что такое **payable**? Это ключевое слово у функции означает, что функция принимает транзакции с отправленным Eth. Это же ключевое слово для **address**, означает, что для этого адреса будут доступны методы `.transfer(..)` и `.send(..)`
* Вместо привычных словарей в Solidity используется **mapping\(\)** в скобках указываются типы ключей и значений. Записывается так:

```text
mapping(uint => address)
```

* Из **mapping** нельзя удалять значения. Это связано с тем, что для EVM Эфира "трудозатратен" сам процесс записи и оперирования данными в storage, что и облагается комиссией. Однако хранение данных абсолютно бесплатно в любых количествах.

